This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-17T19:36:05.782Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
public/
  vite.svg
src/
  components/
    ChatInterface.jsx
    InputArea.jsx
    MessageItem.jsx
    MessageList.jsx
    ModelSelector.jsx
  hooks/
    useChat.js
  services/
    providers/
      anthropic-provider.js
      base-provider.js
      provider-registry.js
    storage/
      chat-storage.js
  App.jsx
  index.css
  main.jsx
.env.example
.gitignore
.prettierignore
.prettierrc
eslint.config.js
index.html
package.json
postcss.config.js
tailwind.config.js
vite.config.js

================================================================
Repository Files
================================================================

================
File: public/vite.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

================
File: src/components/ChatInterface.jsx
================
import React from "react";
import { useChatState } from "../hooks/useChat";
import InputArea from "./InputArea";
import MessageList from "./MessageList";
import ModelSelector from "./ModelSelector";
function ChatInterface() {
  const {
    messages,
    isLoading,
    error,
    sendMessage,
    clearChat,
    model,
    setModel
  } = useChatState();
  const handleSendMessage = async (message) => {
    await sendMessage(message);
  };
  return (
    <div className="container mx-auto p-4 max-w-4xl">
      <div className="flex flex-col space-y-4">
        <ModelSelector 
          currentModel={model} 
          onModelChange={setModel} 
        />
        {error && (
          <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative" role="alert">
            <span className="block sm:inline">{error}</span>
          </div>
        )}
        <MessageList messages={messages} isLoading={isLoading} />
        <InputArea onSendMessage={handleSendMessage} disabled={isLoading} />
      </div>
    </div>
  );
}
export default ChatInterface;

================
File: src/components/InputArea.jsx
================
import React, { useState } from "react";
function InputArea({ onSendMessage, disabled }) {
  const [input, setInput] = useState("");
  const handleSubmit = (e) => {
    e.preventDefault();
    if (input.trim() && !disabled) {
      onSendMessage(input);
      setInput("");
    }
  };
  return (
    <form onSubmit={handleSubmit} className="mt-4">
      <div className="flex">
        <input
          type="text"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          className="flex-grow p-2 border rounded-l-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
          placeholder="Type your message..."
          disabled={disabled}
        />
        <button
          type="submit"
          className={`px-4 py-2 rounded-r-lg ${
            disabled
              ? "bg-blue-300 cursor-not-allowed"
              : "bg-blue-500 hover:bg-blue-600"
          } text-white focus:outline-none focus:ring-2 focus:ring-blue-500`}
          disabled={disabled}
        >
          {disabled ? "Sending..." : "Send"}
        </button>
      </div>
    </form>
  );
}
export default InputArea;

================
File: src/components/MessageItem.jsx
================
import React from "react";
import ReactMarkdown from "react-markdown";
import { Prism as SyntaxHighlighter } from "react-syntax-highlighter";
import { atomDark } from "react-syntax-highlighter/dist/esm/styles/prism";
import remarkGfm from "remark-gfm";
function MessageItem({ message }) {
  return (
    <div
      className={`p-4 rounded-lg ${
        message.role === "user" ? "bg-blue-100" : "bg-green-100"
      }`}
    >
      <ReactMarkdown
        remarkPlugins={[remarkGfm]}
        components={{
          code({ node, inline, className, children, ...props }) {
            const match = /language-(\w+)/.exec(className || "");
            return !inline && match ? (
              <SyntaxHighlighter
                style={atomDark}
                language={match[1]}
                PreTag="div"
                {...props}
              >
                {String(children).replace(/\n$/, "")}
              </SyntaxHighlighter>
            ) : (
              <code className={className} {...props}>
                {children}
              </code>
            );
          },
        }}
      >
        {message.content}
      </ReactMarkdown>
    </div>
  );
}
export default MessageItem;

================
File: src/components/MessageList.jsx
================
import React from "react";
import MessageItem from "./MessageItem";
function MessageList({ messages }) {
  return (
    <div className="space-y-4">
      {messages.map((message, index) => (
        <MessageItem key={index} message={message} />
      ))}
    </div>
  );
}
export default MessageList;

================
File: src/components/ModelSelector.jsx
================
import React from 'react';
import { ModelRegistry, ProviderType } from '../services/providers/provider-registry';
function ModelSelector({ currentModel, onModelChange }) {
  const models = ModelRegistry[ProviderType.ANTHROPIC];
  return (
    <div className="mb-4">
      <label htmlFor="model-select" className="block text-sm font-medium text-gray-700 mb-2">
        Model
      </label>
      <select
        id="model-select"
        value={currentModel}
        onChange={(e) => onModelChange(e.target.value)}
        className="block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
      >
        {Object.entries(models).map(([modelId, model]) => (
          <option key={modelId} value={modelId}>
            {model.name}
          </option>
        ))}
      </select>
    </div>
  );
}
export default ModelSelector;

================
File: src/hooks/useChat.js
================
import { useCallback, useEffect, useState } from 'react';
import { createProvider, ModelRegistry, ProviderType } from '../services/providers/provider-registry';
import { chatStorage } from '../services/storage/chat-storage';
export const MessageRoles = {
  USER: 'user',
  ASSISTANT: 'assistant',
  SYSTEM: 'system'
};
// We'll use React's useState for global state instead of signals
export const useChatState = (conversationId = null) => {
  const [messages, setMessages] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [provider, setProvider] = useState(null);
  const [activeProvider, setActiveProvider] = useState(ProviderType.ANTHROPIC);
  const [activeModel, setActiveModel] = useState('claude-3-sonnet-20240229');
  // Initialize provider and load conversation if ID provided
  useEffect(() => {
    const initChat = async () => {
      // Create provider instance
      const providerInstance = createProvider(activeProvider);
      setProvider(providerInstance);
      // Load conversation if ID provided
      if (conversationId) {
        try {
          const conversation = await chatStorage.getConversation(conversationId);
          if (conversation) {
            setMessages(conversation.messages);
          }
        } catch (err) {
          console.error('Error loading conversation:', err);
          setError('Failed to load conversation history');
        }
      }
    };
    initChat();
  }, [conversationId, activeProvider]);
  // Handle provider/model changes
  useEffect(() => {
    if (activeProvider) {
      setProvider(createProvider(activeProvider));
    }
  }, [activeProvider]);
  const sendMessage = useCallback(async (content) => {
    if (!provider) return;
    setIsLoading(true);
    setError(null);
    // Create user message
    const userMessage = provider.formatMessage(MessageRoles.USER, content);
    const updatedMessages = [...messages, userMessage];
    setMessages(updatedMessages);
    try {
      // Send to API
      const response = await provider.sendMessage(updatedMessages, {
        model: activeModel
      });
      if (!response.success) {
        throw new Error(response.error);
      }
      // Add assistant's response
      const assistantMessage = provider.formatMessage(
        MessageRoles.ASSISTANT,
        response.data.content[0].text
      );
      const newMessages = [...updatedMessages, assistantMessage];
      setMessages(newMessages);
      // Save to storage
      if (conversationId) {
        await chatStorage.updateConversation(conversationId, {
          messages: newMessages,
          lastUpdated: new Date().getTime()
        });
      } else {
        await chatStorage.saveConversation({
          messages: newMessages,
          provider: activeProvider,
          model: activeModel
        });
      }
      return assistantMessage;
    } catch (err) {
      setError(err.message);
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [messages, provider, conversationId, activeModel]);
  const clearChat = useCallback(async () => {
    setMessages([]);
    setError(null);
    if (conversationId) {
      try {
        await chatStorage.deleteConversation(conversationId);
      } catch (err) {
        console.error('Error deleting conversation:', err);
      }
    }
  }, [conversationId]);
  return {
    messages,
    isLoading,
    error,
    sendMessage,
    clearChat,
    provider: activeProvider,
    model: activeModel,
    setProvider: setActiveProvider,
    setModel: setActiveModel
  };
};
// Export for convenience
export const availableModels = ModelRegistry;

================
File: src/services/providers/anthropic-provider.js
================
import Anthropic from '@anthropic-ai/sdk';
import { BaseChatProvider } from './base-provider';
export class AnthropicProvider extends BaseChatProvider {
  constructor(config = {}) {
    super();
    this.client = new Anthropic({
      apiKey: config.apiKey || import.meta.env.VITE_ANTHROPIC_API_KEY,
      dangerouslyAllowBrowser: true
      // TODO: Will need backend API service in future if deploying remotely
    });
    this.defaultModel = config.defaultModel || 'claude-3-sonnet-20240229';
  }
  async sendMessage(messages, options = {}) {
    try {
      const response = await this.client.messages.create({
        model: options.model || this.defaultModel,
        max_tokens: options.maxTokens || 4096,
        system: options.systemPrompt,
        messages: messages.map(msg => ({
          role: msg.role,
          content: msg.content
        })),
        ...options
      });
      return {
        success: true,
        data: response,
        error: null
      };
    } catch (error) {
      console.error('Error in Anthropic API call:', error);
      return {
        success: false,
        data: null,
        error: error.message || 'An error occurred while communicating with Claude'
      };
    }
  }
  formatMessage(role, content) {
    return {
      role: role,
      content: content
    };
  }
}

================
File: src/services/providers/base-provider.js
================
export class BaseChatProvider {
  async sendMessage(messages, options = {}) {
    throw new Error('sendMessage must be implemented');
  }
  formatMessage(role, content) {
    throw new Error('formatMessage must be implemented');
  }
}

================
File: src/services/providers/provider-registry.js
================
import { AnthropicProvider } from './anthropic-provider';
export const ProviderType = {
  ANTHROPIC: 'anthropic',
};
export const ModelRegistry = {
  [ProviderType.ANTHROPIC]: {
    'claude-3-opus-20240229': {
      name: 'Claude 3 Opus',
      contextWindow: 200000,
      provider: ProviderType.ANTHROPIC
    },
    'claude-3-sonnet-20240229': {
      name: 'Claude 3 Sonnet',
      contextWindow: 200000,
      provider: ProviderType.ANTHROPIC
    },
    'claude-3-haiku-20240307': {
      name: 'Claude 3 Haiku',
      contextWindow: 200000,
      provider: ProviderType.ANTHROPIC
    }
  },
};
export function createProvider(type, config = {}) {
  switch (type) {
    case ProviderType.ANTHROPIC:
      return new AnthropicProvider(config);
    default:
      throw new Error(`Unknown provider type: ${type}`);
  }
}

================
File: src/services/storage/chat-storage.js
================
export class ChatStorage {
  constructor() {
    this.dbName = 'chatDB';
    this.storeName = 'conversations';
    this.version = 1;
  }
  async init() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains(this.storeName)) {
          const store = db.createObjectStore(this.storeName, { keyPath: 'id', autoIncrement: true });
          store.createIndex('timestamp', 'timestamp', { unique: false });
          store.createIndex('provider', 'provider', { unique: false });
          store.createIndex('model', 'model', { unique: false });
        }
      };
    });
  }
  async saveConversation(conversation) {
    await this.ensureConnection();
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName], 'readwrite');
      const store = transaction.objectStore(this.storeName);
      const request = store.add({
        ...conversation,
        timestamp: new Date().getTime()
      });
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  async getConversations() {
    await this.ensureConnection();
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName], 'readonly');
      const store = transaction.objectStore(this.storeName);
      const request = store.getAll();
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  async getConversation(id) {
    await this.ensureConnection();
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName], 'readonly');
      const store = transaction.objectStore(this.storeName);
      const request = store.get(id);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  async updateConversation(id, updates) {
    await this.ensureConnection();
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName], 'readwrite');
      const store = transaction.objectStore(this.storeName);
      const getRequest = store.get(id);
      getRequest.onsuccess = () => {
        const conversation = getRequest.result;
        const updatedConversation = { ...conversation, ...updates };
        const putRequest = store.put(updatedConversation);
        putRequest.onsuccess = () => resolve(putRequest.result);
        putRequest.onerror = () => reject(putRequest.error);
      };
      getRequest.onerror = () => reject(getRequest.error);
    });
  }
  async deleteConversation(id) {
    await this.ensureConnection();
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName], 'readwrite');
      const store = transaction.objectStore(this.storeName);
      const request = store.delete(id);
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }
  async ensureConnection() {
    if (!this.db) {
      await this.init();
    }
  }
}
export const chatStorage = new ChatStorage();

================
File: src/App.jsx
================
import React from "react";
import ChatInterface from "./components/ChatInterface";
function App() {
  return (
    <div className="min-h-screen bg-gray-100">
      <ChatInterface />
    </div>
  );
}
export default App;

================
File: src/index.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

================
File: src/main.jsx
================
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import App from './App.jsx'
import './index.css'
createRoot(document.getElementById('root')).render(
  <StrictMode>
    <App />
  </StrictMode>,
)

================
File: .env.example
================
VITE_ANTHROPIC_API_KEY=your_api_key_here

================
File: .gitignore
================
# dependencies
node_modules

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

#build
dist
dist-ssr
*.local

# local env files
# do not commit any .env files to git
.env
.env*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
._*
.Spotlight-V100
.Trashes
repopack.config.json
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

================
File: .prettierignore
================
node_modules
public
dist
egress-map
/*.log
yarn.lock
yarn.error.log
.github
repo-output.txt
detailed_changelog.txt
srwp.code-workspace

================
File: .prettierrc
================
{
  "arrowParens": "always",
  "bracketSameLine": true,
  "bracketSpacing": true,
  "endOfLine": "lf",
  "htmlWhitespaceSensitivity": "css",
  "insertPragma": false,
  "printWidth": 100,
  "proseWrap": "preserve",
  "quoteProps": "as-needed",
  "requirePragma": false,
  "semi": true,
  "singleQuote": false,
  "jsxSingleQuote": false,
  "tabWidth": 2,
  "trailingComma": "es5",
  "useTabs": false,
  "overrides": [
    {
      "files": "*.css",
      "options": {
        "parser": "css"
      }
    }
  ],
  "plugins": ["prettier-plugin-tailwindcss"]
}

================
File: eslint.config.js
================
import js from '@eslint/js'
import globals from 'globals'
import react from 'eslint-plugin-react'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    settings: { react: { version: '18.3' } },
    plugins: {
      react,
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...react.configs.recommended.rules,
      ...react.configs['jsx-runtime'].rules,
      ...reactHooks.configs.recommended.rules,
      'react/jsx-no-target-blank': 'off',
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]

================
File: index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

================
File: package.json
================
{
  "name": "faster-chat",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@anthropic-ai/sdk": "^0.33.1",
    "autoprefixer": "^10.4.20",
    "postcss": "^8.5.1",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-markdown": "^9.0.3",
    "react-syntax-highlighter": "^15.6.1",
    "remark-gfm": "^4.0.0",
    "tailwindcss": "^3.4.17"
  },
  "devDependencies": {
    "@eslint/js": "^9.17.0",
    "@types/react": "^18.3.18",
    "@types/react-dom": "^18.3.5",
    "@vitejs/plugin-react": "^4.3.4",
    "eslint": "^9.17.0",
    "eslint-plugin-react": "^7.37.2",
    "eslint-plugin-react-hooks": "^5.0.0",
    "eslint-plugin-react-refresh": "^0.4.16",
    "globals": "^15.14.0",
    "vite": "^6.0.5"
  }
}

================
File: postcss.config.js
================
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

================
File: tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
export default {
  content: ["./index.html", "./src/**/*.{js,ts,jsx,tsx}"],
  theme: {
    extend: {},
  },
  plugins: [],
};

================
File: vite.config.js
================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})
